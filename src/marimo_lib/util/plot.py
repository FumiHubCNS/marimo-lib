try:
    import json5 as _json
except Exception:
    import json as _json

import re
import numpy as np
import pandas as pd
import plotly.graph_objs as go
from typing import Tuple, Dict
from typing import List, Any, Optional
import plotly.io as pio
import base64

pio.renderers.default = "browser"

def save_fig_as_html(fig, savepath:str = "notebook/figs/figure.html") -> str:
    """
    Plotlyで作成した図をHTMLの形式で保存する関数

    Save a plot generated by Plotly in HTML format.

    Parameters
    ----------
    fig : 
        Instance of plotly.graph_objects.Figure 
    savepath : 
        Output file path 


    Returns
    -------
    str: 
        保存したデータのパス
    """
    pio.write_html(
        fig,
        file=savepath,
        include_plotlyjs="inline",
        full_html=True,
        auto_open=False
    )
    return savepath


def load_html_as_str(input_path:str =  "notebook/figs/figure.html") -> str:
    """
    HTMLを読み込む関数

    Load HTML file.

    Parameters
    ----------
    input_path : 
        Input file path 

    Returns
    -------
    str: 
        String型に格納されたHTMLテキスト
    """
    with open(input_path, "r", encoding="utf-8") as f:
        html = f.read()

    return html


def get_plotly_values_json(text):
    """
    String型で格納されているHTMLテキストからデータの値をjson形式でパースする関数
    
    Parse data values from HTML text stored as a String into JSON format.

    Parameters
    ----------
    text : 
        Original HTML text

    Returns
    -------
    parse_plotly_script(script_js): 
       Tupleに格納された、パース済みHTMLテキストのデータとレイアウトの情報
    """
    keyword = "plotly-graph-div"
    pos = text.find(keyword)
    front = find_right_all(text, "<script", pos)[0] 
    back = find_right_all(text, "</script>", pos)[0] 
    script_js = text[front:back+9]

    return parse_plotly_script(script_js)


def parse_plotly_script(script_js: str) -> Tuple[List[Dict[str, Any]], Dict[str, Any]]:
    """
    <script> 内のテキスト（Plotly.newPlot(...) を含む）から data(list), layout(dict) を返す。
    
    Returns data(list) and layout(dict) from the text within <script> (including Plotly.newPlot(...)).

    Parameters
    ----------
    script_js : 
        Javescript text in string format

    Returns
    -------
    data, layout: 
       Tupleに格納された、パース済みHTMLテキストのデータとレイアウトの情報
    """
    m = re.search(r'Plotly\.newPlot\s*\(', script_js)
    if not m:
        raise ValueError("Plotly.newPlot(...) not found")
    pos = m.end()

    # 第2引数の [data] と 第3引数の {layout} を括弧対応で抜き出す
    data_json, pos_after_data = extract_bracketed(script_js, pos, '[', ']')
    layout_json, _ = extract_bracketed(script_js, pos_after_data, '{', '}')

    data = _json.loads(data_json)
    layout = _json.loads(layout_json)
    return data, layout


def extract_bracketed(s: str, start_pos: int, open_ch: str, close_ch: str) -> Tuple[str, int]:
    """
    s[start_pos:] で最初の open_ch から対応する close_ch までを括弧対応で抜き出す
    
    Extract the data between close_ch and open_ch using bracket matching with s[start_pos:]

    Parameters
    ----------
    s : 
        Original javascript text extracted by self.get_plotly_values_json
    start_pos : 
        Start position
    open_ch : 
        Start channel 
    close_ch :  
        Close channel 

    Returns
    -------
    s[i:j+1], j+1: 
       Tupleに格納された、パース済みHTMLテキストのデータとレイアウトの情報
    """
    i = s.find(open_ch, start_pos)
    if i < 0:
        raise ValueError(f"opening '{open_ch}' not found after {start_pos}")
    depth = 0
    j = i
    in_str = False
    quote: Optional[str] = None
    esc = False
    while j < len(s):
        ch = s[j]
        if in_str:
            if esc:
                esc = False
            elif ch == '\\':
                esc = True
            elif ch == quote:
                in_str = False
                quote = None
        else:
            if ch in ("'", '"', '`'):
                in_str = True
                quote = ch
            elif ch == open_ch:
                depth += 1
            elif ch == close_ch:
                depth -= 1
                if depth == 0:
                    return s[i:j+1], j+1
        j += 1
    raise ValueError(f"no matching '{close_ch}' for '{open_ch}'")


def decode_typed_arrays(obj:Tuple[List[Dict[str, Any]], Dict[str, Any]]):
    """
    Plotlyで保存したHTMLから数値データを取得する関数。
    再帰的に探索し、numpy.ndarrayにデコード
    
    Get numerical data from HTML saved with Plotly.
    Recursively traverse and decode into a numpy.ndarray    

    Parameters
    ----------
    obj : 
        Instance of self.parse_plotly_script()

    Returns
    -------
    output: 
        numpy.ndarray or Tuple[List[Dict[str, Any]], Dict[str, Any]]
    """
    # 配列1個
    if isinstance(obj, dict) and "dtype" in obj and "bdata" in obj:
        dtype = np.dtype(obj["dtype"])
        raw = base64.b64decode(obj["bdata"])
        arr = np.frombuffer(raw, dtype=dtype)
        # 2次元以上
        shape = obj.get("shape")
        if shape:
            if isinstance(shape, str):
                shape = tuple(int(s) for s in shape.split(","))
            arr = arr.reshape(shape)
        return arr

    # リストの場合
    if isinstance(obj, list):
        return [decode_typed_arrays(x) for x in obj]

    # 辞書の場合
    if isinstance(obj, dict):
        return {k: decode_typed_arrays(v) for k, v in obj.items()}

    return obj


def find_left(text: str, needle: str, from_pos: int, *, include_current: bool=False) -> int:
    """
    text の from_pos 位置から左方向に needle（文字列）を探し、直近の一致の開始位置を返す。
    見つからなければ -1。
    include_current=True にすると、from_pos を含む（=右端が from_pos を超えない）範囲も対象。
    
    Searches for the string needle starting from the position from_pos in text, returning the start position of the closest match.
    Returns -1 if no match is found.
    Setting include_current=True includes the range containing from_pos (i.e., the right edge does not exceed from_pos).

    Parameters
    ----------
    text : 
        Original text
    needle : 
        Target text
    from_pos : 
        Starting position
    include_current :
        Flag for including the outside of search range
        
    Returns
    -------
    int: 
        Start position searched to left direction from from_pos 
    """
    end = from_pos + 1 if include_current else from_pos

    return text.rfind(needle, 0, max(0, end))


def find_left_all(text: str, needle: str, from_pos: int, *, include_current: bool=False) -> List[int]:
    """
    左側（from_pos より左、必要なら含む）にある全一致の開始位置をリストで返す（昇順）。
    
    Return a list of all exact match start positions on the left side (to the left of from_pos, including it if necessary) in ascending order.

    ----------
    text : 
        Original text
    needle : 
        Target text
    from_pos : 
        Starting position
    include_current :
        Flag for including the outside of search range

        
    Returns
    -------
    out: 
        Start position searched to left direction from from_pos 
    """
    end = from_pos + 1 if include_current else from_pos
    out = []
    start = 0

    while True:
        i = text.find(needle, start, end)
        if i == -1:
            break
        out.append(i)
        start = i + 1

    return out


def find_left_regex(text: str, pattern: str, from_pos: int, *, flags: int=0, include_current: bool=False) -> int:
    """
    正規表現で左側の最後の一致開始位置を返す。見つからねば -1。

    Returns the starting position of the last match on the left side using regular expressions. Returns -1 if no match is found.
    
    ----------
    text : 
        Original text
    needle : 
        Target text
    from_pos : 
        Starting position
    include_current :
        Flag for including the outside of search range

    Returns
    -------
    out: 
        Start position searched using regular expressions to left direction from from_pos 
    """
    end = from_pos + 1 if include_current else from_pos
    last_start = -1

    for m in re.finditer(pattern, text[:max(0, end)], flags):
        last_start = m.start()

    return last_start


def find_right(text: str, needle: str, from_pos: int, *, include_current: bool=False) -> int:
    """
    text の from_pos 位置から右方向に needle（文字列）を探し、直近の一致の開始位置を返す。
    見つからなければ -1。
    include_current=True にすると、from_pos を含む（=左端が from_pos を超えない）範囲も対象。
    
    Searches for the string needle starting from the position from_pos in text, returning the start position of the closest match.
    Returns -1 if no match is found.
    Setting include_current=True includes the range containing from_pos (i.e., the left edge does not exceed from_pos).

    Parameters
    ----------
    text : 
        Original text
    needle : 
        Target text
    from_pos : 
        Starting position
    include_current :
        Flag for including the outside of search range

    Returns
    -------
    int: 
        Start position searched to right direction from from_pos 
    """
    start = from_pos if include_current else from_pos + 1

    return text.find(needle, max(0, start))


def find_right_all(text: str, needle: str, from_pos: int, *, include_current: bool=False) -> List[int]:
    """
    右側（from_pos より右、必要なら含む）にある全一致の開始位置をリストで返す（昇順）。
    
    Return a list of all exact match start positions on the right side (to the right of from_pos, including it if necessary) in ascending order.

    ----------
    text : 
        Original text
    needle : 
        Target text
    from_pos : 
        Starting position
    include_current :
        Flag for including the outside of search range

    Returns
    -------
    out: 
        Start position searched to right direction from from_pos 
    """
    start = from_pos if include_current else from_pos + 1
    out = []
    n = len(needle)
    i = text.find(needle, max(0, start))

    while i != -1:
        out.append(i)
        i = text.find(needle, i + max(1, n))  # 重なりを拾わない。重なりも拾うなら +1 にする

    return out


def find_right_regex(text: str, pattern: str, from_pos: int, *, flags: int=0, include_current: bool=False) -> int:
    """
    正規表現で右側の最後の一致開始位置を返す。見つからねば -1。

    Returns the starting position of the last match on the right side using regular expressions. Returns -1 if no match is found.
    
    ----------
    text : 
        Original text
    needle : 
        Target text
    from_pos : 
        Starting position
    include_current :
        Flag for including the outside of search range

    Returns
    -------
    out: 
        Start position searched using regular expressions to right direction from from_pos 
    """
    start = from_pos if include_current else from_pos + 1
    m = re.search(pattern, text[max(0, start):], flags)

    return (max(0, start) + m.start()) if m else -1

def get_np_histogram2d(
    data: list = None,
    bins: list = None,
    xrange: list = None,
    yrange: list = None
) -> Tuple[np.ndarray, np.ndarray, np.ndarray]:
    """
    2Dヒストの生カウントとエッジを返す（plotly では z=counts.T を使う想定）

    Parameters
    ----------
    data : 
        2 or 3 dimansional data list [x[1,2,1,...,1], y[3,2,1,...,3], z[3,2,1,...,3]]
    bins : 
        bin information [bin number for x, bin number for y]
    xrange : 
        effective range for x axis [min, max]
    yrange : 
        effective range for y axis [min, max]

    Returns
    -------
    counts, xedges, yedges:
        Tuple returned values with `numpy.histogram2d`
    """
    if data is None:
        return None
    
    if xrange is None:
        xrange = []

    if yrange is None:
        yrange = []
    
    x = data[0]
    y = data[1]

    if len(data) == 2:

        x = pd.to_numeric(x, errors='coerce')
        y = pd.to_numeric(y, errors='coerce')

        mask = ~np.isnan(x) & ~np.isnan(y)
        x_clean = x[mask]
        y_clean = y[mask]

        if len(xrange) >= 2 and len(yrange) >= 2:
            counts, xedges, yedges = np.histogram2d(x_clean, y_clean, bins=bins,range=[xrange, yrange])
        else:
            counts, xedges, yedges = np.histogram2d(x_clean, y_clean, bins=bins) 

    else:
        w = data[2]
        counts, xedges, yedges = np.histogram2d(x, y, bins=bins, weights=w)

    return counts, xedges, yedges

def slice_1d_from_2dhist(
    counts: np.ndarray,
    xedges: np.ndarray,
    yedges: np.ndarray,
    bin_index: int,
    *,
    slice_axis: str = "x",   # 'x' なら xビン固定→y分布, 'y' なら yビン固定→x分布
    bin_span: int = 1,       # 何ビン分まとめるか（[bin_index, bin_index+bin_span)）
    normalize: bool = False,
) -> Dict[str, np.ndarray]:
    """
    二次元ヒストグラムから指定した軸の「ビン範囲」でスライスして、残りの軸の1Dヒストを取り出す。

    Slice the 2D histogram using the specified axis's `bin range` to extract the 1D histogram for the remaining axis.

    Parameters
    ----------
    counts : shape = (nx, ny)
    xedges : shape = (nx+1,)
    yedges : shape = (ny+1,)
    bin_index : int
        スライス開始ビン番号（0 始まり）
        slice_axis == 'x' のとき: 0..nx-1
        slice_axis == 'y' のとき: 0..ny-1
    slice_axis : {'x', 'y'}
        'x' → xビン範囲を固定して y の分布を返す
        'y' → yビン範囲を固定して x の分布を返す
    bin_span : int, default 1
        まとめるビン数。
        例: bin_index=3, bin_span=2 → ビン 3 と 4 を合算。
    normalize : True のとき総和1に正規化

    Returns
    -------
    dict: 
        {
            "counts":  (n_other,),
            "edges":   (n_other+1,),
            "centers": (n_other,),
            "axis":    str,
            "indices": np.ndarray[int],
            "bin_index": int,
            "bin_span": int
        }
    """
    if counts.ndim != 2:
        raise ValueError("counts must be 2D (nx, ny)")

    nx, ny = counts.shape

    if slice_axis not in ("x", "y"):
        raise ValueError(f"slice_axis must be 'x' or 'y', got {slice_axis!r}")

    if bin_span < 1:
        raise ValueError(f"bin_span must be >= 1, got {bin_span}")

    if slice_axis == "x":
        start = bin_index
        stop = bin_index + bin_span
        if not (0 <= start < nx) or stop > nx:
            raise IndexError(
                f"x bin range out of range: start={start}, stop={stop}, nx={nx}"
            )
        # x方向に複数ビンをまとめて y方向に積分
        counts_1d = counts[start:stop, :].sum(axis=0).astype(float)  # (ny,)
        edges = yedges
        centers = 0.5 * (yedges[:-1] + yedges[1:])
        indices = np.arange(start, stop)

    else:  # slice_axis == "y"
        start = bin_index
        stop = bin_index + bin_span
        if not (0 <= start < ny) or stop > ny:
            raise IndexError(
                f"y bin range out of range: start={start}, stop={stop}, ny={ny}"
            )
        # y方向に複数ビンをまとめて x方向に積分
        counts_1d = counts[:, start:stop].sum(axis=1).astype(float)  # (nx,)
        edges = xedges
        centers = 0.5 * (xedges[:-1] + xedges[1:])
        indices = np.arange(start, stop)

    if normalize and counts_1d.sum() > 0:
        counts_1d = counts_1d / counts_1d.sum()

    return {
        "counts": counts_1d,
        "edges": edges,
        "centers": centers,
        "axis": slice_axis,
        "indices": indices,
        "bin_index": bin_index,
        "bin_span": bin_span
    }


def get_slice_array(
    data: list = None,
    bins: list = None, 
    xrange: list = None,
    yrange: list = None,
    slice_axis: str = "x", 
    bin_span: int = 1,
    normalize: bool = False,
    histo_skip: bool = False
) -> list:
    """
    二次元ヒストグラムから任意の便数でまとめた頻度を一次元ヒストグラムのリストとして取得する。

    Get a list of one-dimensional histograms representing counts sliced by any number of bins from a two-dimensional histogram.
        
    Parameters
    ----------
    data : 
        2 dimansional data list [x[1,2,1,...,1], y[3,2,1,...,3]]
    bins : 
        Bin information [bin number for x, bin number for y]
    xrange : 
        Effective range for x axis [min, max]
    yrange : 
        Effective range for y axis [min, max]
    slice_axis : 
        Axis label in string format 
    bin_span : 
        Number of bin to be grouped
    normalize : 
        Normarize option
    histo_skip : 
        Flag to skip numpy.histogram2d

    Returns
    -------
    histo_array: 
        List of one dimensional histogram information 
    """  
    histo_array = []
    data2d = get_np_histogram2d(data, bins, xrange, yrange) if histo_skip is False else data
    max_loop = len(data2d[0][0])//bin_span if slice_axis == 'y' else len(data2d[0])//bin_span

    for i in range(max_loop):
        bin_index = i * bin_span
        data1d = slice_1d_from_2dhist(
                *data2d, 
                bin_index=bin_index,
                slice_axis=slice_axis,
                bin_span=bin_span,
                normalize=normalize,
            )
        histo_array.append(data1d)

    return histo_array

def add_sub_plot(
        fig,
        irow:int = 1,
        icol:int = 1, 
        plot_type="1d",
        data:list = None,
        labels:list = None,
        bins=[200,200],
        logsf:str = None,
        xrange:list = None,
        yrange:list = None,
        debug:bool = False,
        legends:list = None,
        dataname:str = None,
        color:str = None,
        colormap:str = "Viridis"
):
    """
    Plotlyでsub plotを追加する内製関数

    Add subplots in Plotly
        
    Parameters
    ----------
    fig : 
        Instance of plotly.graph_objects.Figure 
    irow : 
        Number of row
    icol : 
        Number of column
    plot_type : 
        Plot type written by string format
    data : 
        2 dimansional data list [x[1,2,1,...,1], y[3,2,1,...,3]]
    bins : 
        Axis information [bin number for x, bin number for y]
    bins : 
        Bin information [bin number for x, bin number for y]
    logsf : 
        Log flag for 3d axies in string format if true -> 1. e.g. 'xyz' -> '001' if you want to set log scale to z.
    xrange : 
        Effective range for x axis [min, max]
    yrange : 
        Effective range for y axis [min, max]
    debug : 
        Flag to dump debug information
    legends : 
        Legend setting. [0], [1]: box position. [2], [3]: box anchor, [4]: box align, [5]: margin. 
    dataname : 
        Data name
    color : 
        Plot color in string format
    colormap : 
        Heatmap in string format
    """  
    if data is None:
        data = []

    if labels is None:
        labels = []

    if bins is None:
        bins = [200, 200]

    if logsf is None:
        logs = [False, False, False]
    else:
        logs = []
        for i in range(3):
            val_bool = True if logsf[i] == "1" else False
            logs.append(val_bool)

    if xrange is None:
        xrange = []

    if yrange is None:
        yrange = []

    xtype = '-' if logs[0] is False else 'log'
    ytype = '-' if logs[1] is False else 'log'
 
    if plot_type == '1d':
        plot_1d(fig, irow, icol, data, bins, xrange, dataname)

    elif plot_type == '2d':
        plot_2d(fig, irow, icol, data, bins, logs, xrange, yrange, debug, dataname, colormap)
    
    elif plot_type == 'scatter':
        plot_scatter(fig, irow, icol, data, dataname, color)

    elif plot_type == 'fit':
        plot_fit(fig, irow, icol, data, dataname, color)

    elif plot_type == 'plot':
        plot_plot(fig, irow, icol, data, dataname, color)

    elif plot_type == 'spark-hist':
        plot_spark_hist(fig, irow, icol, data, dataname)
    
    elif plot_type == 'error':
        plot_error(fig, irow, icol, data, dataname, color)    

    if len(labels) >=2:
        fig.update_xaxes(
            type = xtype,
            title_text = labels[0],
            row = irow,
            col = icol
        )

        fig.update_yaxes(
            type = ytype,
            title_text = labels[1],
            row = irow,
            col = icol
        )

    if legends is not None:
        if len(legends) > 5:
            fig.update_layout(
                legend=dict(
                    x = legends[0],
                    y = legends[1],   
                    xanchor = legends[2],
                    yanchor = legends[3],
                    orientation = legends[4]  
                ),
                margin=dict(r = legends[5])               
        )
            
####################################################
### user define plot function
####################################################

def plot_1d(fig, irow, icol, data, bins, xrange, dataname):
    """
    `plot_type`='1d'での描画関数

    plot function with `plot_type`='1d'
    """  
    if len(xrange) < 2:
        fig.add_trace(
            go.Histogram(x=data[0],nbinsx=bins[0],name=dataname),
            row=irow, col=icol
        )
    else:
        fig.add_trace(
            go.Histogram(
                x=data[0],
                xbins=dict(
                    start=xrange[0],   
                    end=xrange[1], 
                    size=xrange[2] 
                ),
                name=dataname
            ),
            row=irow, col=icol
        )


def plot_2d(fig, irow, icol, data, bins, logs, xrange, yrange, debug, dataname, colormap):
    """
    `plot_type`='2d'での描画関数

    plot function with `plot_type`='2d'
    """  
    counts, xedges, yedges = get_np_histogram2d(data=data, bins=bins, xrange=xrange, yrange=yrange)
    
    if logs[2]:
        counts = np.log10(counts + 1)

    bar_title = "ln(+1)" if logs[2] else "Count" 

    xcenters = 0.5 * (xedges[:-1] + xedges[1:])
    ycenters = 0.5 * (yedges[:-1] + yedges[1:])

    heatmap = go.Heatmap(
        x=xcenters,
        y=ycenters,
        z=counts.T,
        colorscale=colormap,
        colorbar=dict(
            title=bar_title
        ),
        name=dataname
    )
    
    fig.add_trace(heatmap, row=irow, col=icol)

    rows_range, cols_range = fig._get_subplot_rows_columns()
    ncols = len(cols_range)

    index = (irow - 1) * ncols + (icol - 1)
    base_title = fig.layout.annotations[index].text 
    fig.layout.annotations[index].text = f"{base_title}, Entries:{int(counts.sum())}"

    if debug:
        total_count = counts.sum()

        max_val = counts.max()
        max_index = np.unravel_index(np.argmax(counts), counts.shape)
        iy, ix = max_index

        xcenters = 0.5 * (xedges[:-1] + xedges[1:])
        ycenters = 0.5 * (yedges[:-1] + yedges[1:])

        x_at_max = xcenters[ix]
        y_at_max = ycenters[iy]

        min_val = counts.min()
        min_index = np.unravel_index(np.argmin(counts), counts.shape)
        iy, ix = min_index

        x_at_min = xcenters[ix]
        y_at_min = ycenters[iy]

        print(f"[debug] Entries {total_count}, Max value {max_val} at ({x_at_max},{y_at_max}), Min value {min_val} at ({x_at_min},{y_at_min})")


def plot_scatter(fig, irow, icol, data, dataname, color):
    """
    `plot_type`='scatter'での描画関数

    plot function with `plot_type`='scatter'
    """  
    if color is not None:
        fig.add_trace(
            go.Scatter(
                y = data[0],
                mode = 'lines+markers',
                marker = dict(size = 4, color = color),
                line = dict(width = 1, color = color),
                name = dataname
            ),
            row=irow, col=icol
        )
    else:
        fig.add_trace(
            go.Scatter(
                y = data[0],
                mode = 'lines+markers',
                marker = dict(size = 4),
                line = dict(width = 1),
                name = dataname
            ),
            row = irow,
            col = icol
        )  


def plot_fit(fig, irow, icol, data, dataname, color):
    """
    `plot_type`='fit'での描画関数

    plot function with `plot_type`='fit'
    """ 
    if color is not None:
        fig.add_trace(
            go.Scatter(
                x = data[0],
                y = data[1],
                mode = 'lines',
                marker = dict(
                    size = 4,
                    color = color
                ),
                line = dict(
                    width = 2,
                    color = color
                ),
                name = dataname
            ),
            row = irow,
            col = icol,
        )
    else:
        fig.add_trace(
            go.Scatter(
                x = data[0],
                y = data[1],
                mode = 'lines',
                marker = dict(size = 4),
                line = dict(width = 2),
                name = dataname
            ),
            row = irow,
            col = icol,
        )


def plot_plot(fig, irow, icol, data, dataname, color):
    """
    `plot_type`=plot'での描画関数

    plot function with `plot_type`='plot'
    """ 
    if color is not None:
        fig.add_trace(
            go.Scatter(
                x = data[0],
                y = data[1],
                mode = 'markers',
                marker = dict(
                    size = 8,
                    color = color
                ),
                line = dict(
                    width = 1,
                    color = color
                ),
                name = dataname),
            row = irow, 
            col = icol
        )
    else:
        fig.add_trace(
            go.Scatter(
                x = data[0],
                y = data[1],
                mode = 'markers',
                marker = dict(size = 8),
                line = dict(width = 1),
                name = dataname
            ),
            row = irow,
            col = icol
        )


def plot_spark_hist(fig, irow, icol, data, dataname):
    """
    `plot_type`='spark-hist'での描画関数

    plot function with `plot_type`='spark-hist'
    """ 
    fig.add_trace(
        go.Bar(
            x = data[0],
            y = data[1],
            name = dataname
        ),
        row = irow,
        col = icol
    )


def plot_error(fig, irow, icol, data, dataname, color):
    """
    `plot_type`='error'での描画関数

    plot function with `plot_type`='error'
    """ 
    if color is not None:
        fig.add_trace(
            go.Scatter(
                x = data[0],
                y = data[1],
                mode = "markers",
                name = dataname,
                error_y = dict(
                    type = "data",
                    array = data[3],
                    arrayminus = data[2],
                    visible = True
                )
            ),
            row = irow,
            col = icol
        )
    else:
        fig.add_trace(
            go.Scatter(
                x = data[0],
                y = data[1],
                mode="markers",
                marker = dict(size = 4),
                line = dict(width = 1),
                name = dataname,
                error_y = dict(
                    type="data",
                    array = data[3],
                    arrayminus = data[2],
                    visible = True
                )
            ),
            row = irow,
            col = icol
        ) 


def align_colorbar(fig, thickness=20, thicknessmode="pixels"):
    """
    二次元ヒストグラムのカラーバーを配置する

    Adjust the color bar positions for the two-dimensional histogram
        
    Parameters
    ----------
    fig : 
        Instance of plotly.graph_objects.Figure 
    thickness : 
        Color bar width
    thicknessmode : 
        Width unit
    """  
    for trace in fig.data:
        if isinstance(trace, go.Heatmap):
            xaxis = "xaxis" if trace.xaxis == "x" else "xaxis" + trace.xaxis[1:]
            yaxis = "yaxis" if trace.yaxis == "y" else "yaxis" + trace.yaxis[1:]

            xa = fig.layout[xaxis].domain
            ya = fig.layout[yaxis].domain

            trace.update(colorbar=dict(thickness=thickness, thicknessmode=thicknessmode, x=xa[1] + 0.01, y=(ya[0] + ya[1]) / 2, len=ya[1] - ya[0]))
